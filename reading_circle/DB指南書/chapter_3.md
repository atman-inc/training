# 論理設計と正規化〜なぜテーブルは分割する必要があるのか〜

学習者：m.sasaki


### 背景
- 今までは正規形、正規化という言葉を知らず、単純にこうするべきだと思ってテーブル設計をしてしまっていた
- 正規形を知らなかったがなんとなくテーブルを分けて設計をしていた
- ここでしっかりと背景を理解して正規化を行えるようにしたい
- 併せて正規化をあえてしない選択をする場面も理解できるようにする


### テーブルとは
- テーブル
  - 共通点を持ったレコードの集合体
  - テーブル名は全て「複数形」または「複数名詞」で書ける

---

### テーブルの構成要素
- **行と列**
  - 列：カラム、属性
  - 行：レコード

<br>

- **キー**
  - RDBになくてはならないもの
    - 主キー
      - Primary Key
      - テーブルに重複行を許さない
    - 外部キー
      - Foreign Key
      - あるテーブルに「**参照整合性制約**」を課す
    - 複合キー
      - 複数のカラムで主キーを設定
    - 候補キー
      - 主キーとして利用可能なキーが複数存在する場合に候補になるキー
    - スーパーキー
      - 複合キーを設定する際に無関係のカラムを含めた場合の、無関係の列のこと

<br>

※候補キー、スーパーキーはあまり重要な役割は果たさない

<br>

#### 外部キーは人間の親子関係と同じ

- 親のテーブルのレコードを**更新・削除**する時の挙動
  - 「親のいない子」レコードも一緒に削除する
    - **カスケード**という
  - 親テーブルの削除SQLをエラー処理を行う

※上記問題を考えないようにテーブル操作を行うのが一番

<br>

#### 外部キーが設定されている場合、データの削除は子から順に行う

<br>

- **キーに設定する列**
  - **表記体系の定まった固定長文字列**を使用する
    - 可変長文字列だと微妙に違う文字列などが混ざる危険がある
  - コードやIDといったデータを利用する

<br>

- **制約**
  - NOT NULL制約
    - データ登録時にデータが定まっていない値をNull（空欄）にできるがそれを許さない制約
    - Nullを登録、更新しようとする際にSQLエラーを起こす
    - 列に可能な限り設定する制約
  - 一意制約
    - 一意性を求める制約
    - 主キーと似ているが、主キーはテーブルに1つ、一意制約は何個でも設定可能
  - CHECK制約
    - カラムの値の範囲を制限する制約
    - 複数列にまたがった制約は出来ない

<br>

- **テーブルと列の名前**
- 命名規則(標準SQL)
  - 名前に使える文字
    - 半角アルファベット
    - 半角数字
    - アンダーバー（_）
  - 最初の文字はアルファベット
    - 数字やアンダーバーを先頭に使用しない
  - 名前の重複は許さない
    - 同じ名前のテーブル、列（カラム）は存在してはいけない
    - そもそもエラーになる
    - テーブルの名前についてはDBMSが定める範囲内では重複した名前は許されない（範囲外であれば重複した名前が許される）

※DBMSが定める範囲を「**ドメイン**」や「**スキーマ**」と呼ぶ

---

### 正規化
- **正規系の定義**
  - 保持するデータの冗長性を排除
  - 一貫性と効率性を保持するデータ形式

<br>

- **冗長性**
  - 1つの情報が複数のテーブルに存在し、無駄なデータ領域と面倒な更新作業を発生させること

<br>

- **非一貫性**
  - データの不整合
  - 登録が行えない状態

<br>

---

### 第1正規形
_1つのセルに1つの値しか含まない状態_

<br>

- 1つのセルに1つの値が入っている時に、その値のことを「**スカラ値**」と呼ぶ

- **関数従属性**
  - ある1つの値を決めればそれに紐付いて決まる値の関係性のこと
    - 例：
      - 社員ID　→　社員名
      - 社員IDが決まれば、社員名が確定する

---

### 第2正規形
_部分関数従属を解消し、完全関数従属のみの形にすること_

<br>

- **部分関数従属**
  - 複数の属性（カラム）からなるテーブルで、主キーに対して一部の属性が従属している状態

<br>

- **完全関数従属**
  - 複数の属性（カラム）からなるテーブルで、主キーに対して全ての属性が従属している状態

- **部分関数従属の解消の仕方**
  - テーブルの分割
  
#### 正規化は現実での階層の差を反映する作業とも考えられる

- **第2正規化メモ**
  - 分割前の状態に戻せる（可逆的）
    - テーブルの結合
  - 無損失分解

---

### 第3正規形
_推移的関数従属の解消をした形にすること_

<br>

- **推移的関数従属**
  - 関数従属関係から新しい関数従属が成立する関係
    - 例：
      - X = Y　のとき　Y = Z　だとすると　X = Z　が成立する関係

<br>

- **第3正規化メモ**
  - 分割前の状態に戻せる（可逆的）
    - テーブルの結合
  - 無損失分解


- 第3正規化以降
  - ボイスーコッド正規化（非公式で第3.5正規化）
  - 第4正規化
  - 第5正規化

**第3正規化まで意識して行えれば問題ないため以降は割愛**

---

### 正規化まとめ

- **更新時の不都合・不整合を排除するために行う**
- **従属関係を見抜くこと**
- **いつでも結合で戻すことが可能**

<br>

- **正規化の必要性**
  - 原則として第3正規化までは必要
    - とはいえ欠点としてパフォーマンスが悪くなる
      - そのため意図的に正規化をしないケースはある

---

### 関数従属の概念を理解して活用
  - 関数従属
    - ある1つの値を決めればそれに紐付いて決まる値の関係性のこと
      - 例：
        - 社員ID　→　社員名
        - 社員IDが決まれば、社員名が確定する
  - 部分関数従属・・・第2正規化
    - 複数の属性（カラム）からなるテーブルで、主キーに対して一部の属性が従属している状態
  - 完全関数従属・・・第2正規化
    - 複数の属性（カラム）からなるテーブルで、主キーに対して全ての属性が従属している状態
  - 推移的関数従属・・・第3正規化
    - 関数従属関係から新しい関数従属が成立する関係
      - 例：
        - X = Y　のとき　Y = Z　だとすると　X = Z　が成立する関係

---