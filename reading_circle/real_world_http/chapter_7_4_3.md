# 7.4.3 から

「7.4  新たなJavaScript用の通信API」の続き

@koushisa

## 7.4.3 WebSocket

- サーバー/クライアント間で、オーバーヘッドの小さい双方向通信を実現する
  - フレーム単位で送受信する
  - 相手が決まっているため送信先の情報などは持たない
  - Bodyのみを送っているようなもの
- RFC6455で定義されており、ブラウザ向けAPIはW3Cで定められている
- チャットや通知などリアルタイムな双方向のアプリケーションで利用されるケースが多い

### WebSocketはステートフル

- HTTPベースのプロトコルと異なり、WebSocketはステートフルであることが大きな違いである
  - 双方向通信を実現するためサーバーのメモリ上にデータを持った状態で通信するケースが多い
- サーバーのメモリを利用するさい、アプリ規模によって負荷分散の適切な手法が変わってくる
  - テキストチャットのような小規模
    - Key Value Store(Memcached, Redis)を中継する
  - 複数人リアルタイム同期プレイのような大規模
    - 「ルーム」のような単位でコネクションを管理する
  - 接続が切れた場合の再接続の要件によってはロードバランサーをあえて利用しないというのもあり得る

### WebSocket接続

- HTTP/2
  - 4章のプロトコルアップグレードと似た仕組みを利用する
    - https://developer.mozilla.org/ja/docs/Web/HTTP/Protocol_upgrade_mechanism#upgrading_to_a_websocket_connection
  - 通常のHTTPとしてスタートし、そのなかでWebSocketにスイッチする
  - その後はDATAフレームを使って双方向通信を行なう
- HTTP/1.1
  - WebSocketの接続用の特殊なメソッドとヘッダーを送信していた
  - Sec-WebSocket-Keyを元にハッシュでSec-WebSocket-Acceptを生成して通信確立を検証する
  ```
  GET /chat HTTP/1.1
  Host: server.example.com
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Key: dGhlHNhbXHogeHoge

  HTTP/1.1 101 Switching Protocols
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Accept: s3pHpLlHogeHoge
  Sec-WebSocket-Protocol: chat
  ```

### Socket.IO

- WebSocketを使いやすくするライブラリ
- 利点
  - WebSocketが使用できない場合はXMLHttpRequestによるロングポーリングでエミュレーションする
  - サーバー側で使える実装もあり、フォールバックのXMLHttpRequestをハンドリングしたりできる
  - WebSocketの切断時に再接続を自動で行なう
  - ロビー機能
- 当初は後方互換性を広く維持できることで人気だった
  - 現代ではWebSocketが使えないブラウザはほとんどないため使われるシーンは減っている

## 7.5 WebRTC(Web Real-Time Communication)

- テレビ電話などのリアルタイムコミュニケーションを実現するための基盤として設計された
  - ブラウザ/サーバー間の通信だけでなく、ブラウザとブラウザのP2P通信でも使う
- これを利用して実現したいアプリの特性はその他のアプリと異なるため、機能郡も変わる
  - トランスポート層はTCPではなく、UDP
  - NAT超えの技術
- 各構成技術はWebRTC用に開発されたものではない
  - 古くからテレビ電話用に開発されてきた技術
  - リアルタイム向けのTLS暗号化を加えたデータグラム通信
- RFC7478でユースケースが定義されており、APIの使用方法などはwebrtc.orgにまとめられている
  - https://webrtc.org/
  - 既存技術を利用し、ブラッシュアップしたものを組み合わせているので分量が多い
- 日本におけるWebRTC情報の多くは時雨堂が発信元になっている
  - https://gist.github.com/voluntas/67e5a26915751226fdcf
  - 本書籍ではWebRTCの構成技術への深堀りは避けている、事始めは上記を参考にするとよい

### 7.5.1 WebRTCのユースケース (P2P)

- 比較的シンプルなユースケースの紹介
- 基本的にUDPで通信される
  - 通信量制限などは自前で実装しなければならない
- シンプルといってもブラウザはたくさんのタスクをこなさなければならない
  - 入力にマイクとビデオカメラ
  - 音声動画の圧縮/展開
  - ネットワーク帯域によるビットレート制御

#### シンプルなビデオ通話システム

- 2人でビデオ会議を行なうシステム
- 全参加者がブラウザを利用して同じサービスプロバイダーにログインして通話する
- 各参加者の状態は、サービスプロバイダーがWebアプリ上で公開する
- 各ユーザーの利用可能な操作
  - メンバーとの通話
    - 特定の誰かを指定して一対一の通話を招待できる
    - 招待の承認/拒否
  - 動画
    - 表示のオン/オフ
    - サイズ変更
  - 自分や相手のオーディオやビデオをミュート/再開
- Webサービスが起点となる点が特徴

#### ファイアウォール越しのビデオ通話

- シンプルビデオ通話システムへ以下の非機能要件が加わる
  - 一部ユーザーが、UDPが送信できないファイアウォール越しで使える
  - 一部ユーザーが、HTTPプロキシ経由の通信しか許可されないファイアウォールでも使える

#### グローバルなネットワークでのビデオ通話

- サービスプロバイダーが世界規模で提供されている
- ユーザーIDなどなにかしらの情報を元に相手を探し出す
- NAT超えの技術が必要になることもある
  - STUN (Session Traversal Utilities for Nat)
  - TURN (Traversal Using Relay Nat)
  - さらにIPv4, IPv6などの要件ごとに別々に構築する可能性もある

#### エンタープライズ環境でのビデオ通話

- 社内から社外への通話を管理できる必要がある
- 内部ネットワークと外部ネットワークをまたぐTURNサーバーを設置する
- ファイアウォールは監視されているTURNサーバーを使わない通信をブロックする

#### スクリーン共有

- ビデオの代わりに現在見えているデスクトップを相手に送信する

#### ファイル交換

- 複数人とビデオ会議をしながら特定の相手にファイルを送信する

#### ホッケーゲームビューア

> RFCにかかれている例が具体的すぎるのですが、そのまま引用します

- アイスホッケーチームのスカウトと監督が新しい選手を発掘しようとしている
- ゲームが始まるとスカウトはスマホで
  - リアカメラでホッケーの試合を移す
  - フロントカメラで自分を写す
- 通話先の監督のデスクトップPCでは
  - ブラウザの画面に大きくホッケーの試合
  - ピクチャーインピクチャーでスカウトの顔とWebカメラの自分の顔

#### 複数人でのビデオ会議

- 中央サーバーなしで複数人同時のビデオ会議を行なう
- それぞれのブラウザは他の全参加者とセッションが確立している
  - お互いに動画と音声のストリームを送受信する
- 必要な機能
  - 音量のバランスを調整するミキシング機能
  - 話をしている人の動画を大きくする
  - 音声の左右バランス調整

#### 複数人でのボイスチャット付きのオンラインゲーム

- 映像はないが、代わりにゲームデータをブラウザ間で送信する
  - ゲームデータの優先度は音声よりも上
- 音声の音位は映像の位置ではなく、ゲームスクリーン内の他のプレイヤーの操作位置によって決まる
- 音声とゲーム内のSEをミックスして再生する
