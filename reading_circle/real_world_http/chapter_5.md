# HTTP/1.1のセマンティクス: 広がるHTTPの用途

@koushisa


- HTTP1/1になるとインターネットは一般の人にも広く使われるようになった
- 様々な端末がインターネットに接続し、応用範囲が広がってくる
  - 技術の進化に伴ってセマンティクスも広がる
    - 「HTMLを取得してくるプロトコル」 から 「汎用的なデータ通信のプロトコル」
    - HTTPのミドルウェアの発達によるインフラ化
- 本章ではHTTP/1.1の規約を使った様々な事例を紹介する

## 5.1 ファイルをダウンロードした後でローカルに保存

- ブラウザがファイルをどう処理するかは、MIMEタイプによって制御される
  - 例
    - image/pngであれば画像ファイルとみなしてブラウザ内で表示
    - インライン表示不可なMIMEタイプであればダウンロードとなる

### 5.1.1 ファイルを保存させる Content-Disposition ヘッダー

- ブラウザはレスポンスヘッダーのContent-Dispositionに含まれる内容によって動作を変更する
  - ウェブページとして表示する
  - ダウンロードしてローカルに保存する
- 以下は.xlsxファイルをダウンロードしてローカルに保存する例
  ```
  Content-Disposition: attachment; filename=filename.xlsx
  ```

### 5.1.2 デフォルトファイル名に日本語を使う

- Content-Dispositionのエンコーディングに関するRFCが存在する
- このルールに則ってエンコーディングするとUTF-8でエンコードされた名前のファイル名を扱える
  - 一部対応していないブラウザが一部存在する点に注意
  - 例えば以下の場合は「ファイル名.xlsx」という名前でローカルに保存される
    ```
    Content-Disposition: attachment; filename*=utf-8'' ファイル名.xlsx; filename=filename.xlsx
    ```
    *がついていない側のfilenameは後方互換性のために指定してあり、エンコーディングに対応していないブラウザではこちらにフォールバックする形となる。
  - 以下はfilenameでエンコードが指定されていないのでファイル名は文字化けする
    ```
    Content-Disposition: attachment; filename="テスト画像.jpg"
    ```

### 5.1.3 ブラウザ内で表示

```
Content-Disposition: inline
```
このように指定するとブラウザは明示的にインライン表示するが、あまり必要になることはない

## 5.2 ダウンロードの中断、再開

- ダウンロードが中断してしまった時に途中から再開する方法が提供されている
- サーバー側がサポートしている場合はAccept-Rangesヘッダーにより実現可能
-  サーバー
  - レスポンスヘッダーにAccept-Rangesを付与する
  ```
  Accept-Ranges: ${value}
  ```
  - valueには2種類の値を取ち、それぞれ以下の意味を持つ
    - bytes: 範囲指定ダウンロードを受け入れる。単位はバイト指定
    - none: 範囲指定ダウンロードを受け入れない
- クライアント
  - Rangeヘッダをリクエストに付与する
  - バイトは0から数えるという点に注意
  - 下記は1001バイト目から2000バイト目までの1000バイトのコンテンツを要求している
    ```
    Range: bytes=1000-1999
    ```
    ※ ダウンロード対象のファイルが途中で変更されると意味がないので、対象ファイルのEtagヘッダもサーバから受け取るようにすること
  - 様々な指定方法が存在する
    - If-Range (条件付きGET)
    - Ranges (複数範囲指定)

### 5.2.2 並列ダウンロード

- 15年以上前は通信回線が不安定だったため、ダウンローダーと呼ばれるアプリケーションが普及していた
  - その中では並列ダウンロードがよく実装されていた
- ただし並列ダウンロードはサーバーへ負荷をかけるためあまり推奨されていない
  - 現在は静的ファイルをキャッシュして返すCDNが普及しておりサーバー負荷も減る技術的な基盤が整ってきている

## 5.3 XMLHttpRequest

- curlコマンドに相当する機能をJavaScriptから使えるようにするもの
- ヘッダ、クッキー、キャッシュなどの制御をプログラマティックに制御できる
```
var xhr = new XMLHttpRequest();
xhr.open("GET", "/json", true);

// レスポンスが返ってきたとき
xhr.onload = function() {
  if (xhr.status === 200) {
    // JSONパースして表示
    console.log(JSON.parse(xhr.responseText))
  }
}

```
