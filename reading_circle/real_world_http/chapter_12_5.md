# 12章 ウェブアプリケーションの基礎

@koushisa

## 12.5 インフラ構成

### 開発環境

- サーバ
  - ほとんどのウェブアプリケーションサーバはWebサーバー機能を持っておりテスト表示も可能
  - JavaのTomcat, Glassfishなど
- フロントエンド
  - アプリケーションが複雑化するにつれてJavaScript, CSSもビルドツールを利用するようになってきた
    - 目的はファイル分割、変数解決、マルチブラウザ対応(polyfill), などさまざま
    - JavaScript: webpack, Babel, TypeScript...
    - CSS: sass, PostCSS
  - ホットリロード
    - 開発環境内のソースコードの変化を検知して自動的にオンメモリでビルドして反映する
  - ホットモジュールリプレースメント
    - フロントエンドの状態を維持したままコンポーネントのソースを書き換える機能
    - フォームの状態はそのままに見た目の軽微な変更だけを動的に反映できる

### 本番環境

- パフォーマンスを出すために前段でApache, Nginxなどがよく配置される
  - 静的コンテンツ: 前段のサーバ
  - 動的コンテンツ: アプリケーションサーバ
- クラウド化によってスケールアウト(サーバーの台数を増やして処理を分散させる)が容易になってきている
  - コンパイル言語よりも（一般的に）実装速度の早いスクリプト言語(Python, Ruby, PHP, Node.js)に人気が集まっている
  - スクリプト言語にはグローバルインタプリタロックという機構で、同時実行スレッドが1つに限定されていることがある
- スクリプト言語を本番環境で並列動作する手法は言語によって異なる
  - PHP
    - fsm-phpというfast-cgiクライアント内に複数のPHPプロセスを起動する
  - Ruby
    - Rackでウェブサーバー同士を接続する
  - Python
    - WSGI, ASGIなどのイベント駆動な非同期I/Oで処理
  - Node.js
    - PM2(プロセスマネージャー)というマスターノードが動作している
    - マスターノードはコア数と同じ数だけ起動しているNode.jsのプロセスにロードバランスする

## 12.6 その他のインフラ形態

### PaaS(Platform as as Service)

- OS, インスタンス管理などのインフラ構成をまとめてサービスとして提供している
- コードをそのままデプロイできるので初速が早く、運用も楽
  - Google App EngineやHerokuなど
- サービスごとに趣向や制約は大きく異なる

### サーバーレス

- AWSのLambda,Aurora, GCPのCloud Functionsなど多種多様
- 処理の結果をストレージに書き込んで別のサーバーレスに連鎖するなど、ワークフローを実現できる
- 処理の流れ
  1. リクエストをうける
  2. サービスを立ち上げる
  3. 処理
  4. 終わり次第サービスを終了する
- 負荷に応じてインスタンス数を自動で増やしたり減らしたりできる
  - アクセスがほぼ無くなると稼働するインスタンスもゼロとなり運用コストを抑えられる
  - 現実的には最低限1台起動しておく、スケーリングのしきい値などの戦略を立てて設定する必要はある

### マイクロサービス

- 小さなサービスを組み合わせてサービスを作るという設計方針
  - Amazon, Netflixなどの大企業が導入している
- 方法論がまだなく、技術的な難易度が高い
  - 分散している非同期のトランザクションの扱い
  - 後方互換性の維持
  - サービス間のスキーマ/インタフェース管理

## 12.7 ウェブアプリケーション内部の階層構造

### ミドルウェア

- セッション確認やロギングなど、毎回行なう同じの処理を共通化できる仕組み
- ハンドラの前後に実行されるフィルターのようなモノ
- 例
  - JavaのServlet
  - PythonのWSGI
  - Node.jsのExpress
- Expressはミドルウェアに徹底している

## 12.8 ウェブアプリケーション構成要素の詳細な分類

- ウェブアプリケーションには大別して4つの箱がある
  1. メソッドとパス
  2. ヘッダー
  3. ボディ
  4. ステータス
- さらにより細かい分類は可能
  - 例)パスの末尾のクエリパラメータ
- 制約内であればリクエストの情報をすべてパスに乗せてしまうなども不可能ではない
- 理解を効率的にするために情報の種類ごとにこのデータはここの箱に入れるべきだとする意思決定が必要
  - これがウェブAPIの設計である

## 12.9 ウェブ」APIの設計 - 箱の使い分け

- 設計は仕様から自動で導出できるものではなく、過去の経験を元に意思決定する
- 基本的にはMECE(もれなく、重複なく)だが、ブラウザ→サーバーでは次のような決定が多い
  - データの操作対象の選択であればパス
  - データの見方、フィルタだけの情報はクエリ
  - URL共有で見えたら困るデータはボディ
  - データの操作の種類はメソッド
  - 認証に関わるデータはヘッダー
- 近年はRestful APIと呼ばれるものが大半だが、正解はない
  - 一般的な方法に近いほど学習コストが低くなりドキュメントを整備しなくても理解してもらいやすい
- 意思決定したうえで不要なデータの箱はCDNやWAFでフィルタリングしたりする
  - セキュリティの強化 = 設計自由度を縛る
    - GET/POST以外のアクセスを禁止する
    - 特定のパスへのアクセスを遮断する
- メソッド制限の例
  - /deleteを末尾につけるなどしてパスの箱にいれる
  - GETの場合はボディを使わずクエリにデータを入れる
