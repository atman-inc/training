# 14章 セキュリティ:ブラウザを守るHTTP機能

## 14.8 リスト型アカウントハッキング
ユーザーのIDやメールアドレス、パスワードなどのログイン登録情報が漏れた際に、他のサービスでも同じものを使用していた際はセキュリティが無効になること。
自社でパスワード情報を保管するのでなく、Google、Facebook、Line、Auth0、AWS Cognitoなどのサービスを利用して外部サービスを利用することでリスクを抑えられる。

### 14.8.1 パスワードのストレッチ: 平文でのパスワード保存をしない
パスワードをそのままDBに保存するのでなくハッシュ化して保存することで、流出時に他のサービスでそのパスワードをそのまま使用されるリスクは減る。
レインボーテーブルという計算済のハッシュ値の対応表があり、それを参照しハッシュ値から逆算できてしまうこともある。
ソルトと呼ばれる文字列の後に一律で文字列を付与することで、ハッシュ値のセキュリティを強化することができる。

### 14.8.2 各種パスワード保管時に使うハッシュ関数
アルゴリズムの種類
- bcrypt
- PBKDF2
- Argon2
- scrpt

最近ではウェブフレームワークにデフォルトでパスワードのハッシュ化機構が組み込まれている。
- PHPでは、言語組み込みでbcryptが使用できる
- Ruby on Railsではチュートリアルの中でbcryptを使用しパスワードのストレッチをする方法が紹介されている
- Goは準標準ライブラリで各種アルゴリズムが提供されている

### 14.8.3 パスワードのログのマスク化
問題の追跡、ユーザーのオペレーションの改善のためにアクセスログなどを収集するのが一般的。
ただそのログの中に、パスワードや住所などの個人情報を潰すマスク化が必要。
- 社内から個人情報にアクセスできる手段を制限
- アクセスできる社員の権限管理

機械学習でデータの分析を行いたい場合、
- 住所とユーザーが紐付かないようにする
- ハッシュ化し同一かどうかだけでわかるようにする

### 14.8.4 多要素認証(MFA)
リスト型攻撃に対する対策。
- 2段階認証
- 2要素認証
- 多要素認証

多要素認証とは、下記の要素を複数組み合わせたもの。
なおパスワードと秘密の質問はどちらも記憶なので多要素認証にならない。
- ユーザーが持つ記憶: パスワード
- ユーザーが所有する要素: ソフトウェア、ハードウェア
- 生まれつき持っている要素: 指紋、光彩認証、顔認証

### 14.8.5 タイムベースタイムパスワードアルゴリズム(TOTP)
ユーザーが所有する要素としてよく利用されている。
ランダムなビット列の値をパスワード(シークレット)とする。
そこにユーザー名などを付与してURLっぽくする。スキーム名はotpauth。
ユーザー側はシークレットと現在時刻で6桁の数値を生成しサービスに送信。サービス側は現在時刻で6桁の数値でシークレットを生成し一致するか確認。
Google Authenticationなど。

### 14.8.6 WebAuthn (Web Authentication)
ブラウザで、ユーザーが所有する要素(bluetooth, wifi)、生まれつき持っている要素(指紋)などを利用して簡単に多要素認証ができる仕組み。
クライアントが認証の開始を申し出ると、サーバは「チャレンジ」と呼ばれる乱数を元に決めた毎回異なるデータ列を送信する。クライアントはセキュリティキーとして選択したものとチャレンジを組み合わせ、これをハッシュ関数を通してハッシュ値に変換したものを「レスポンス」としてサーバに返信し認証を行うもの。

チャレンジ-レスポンス認証: https://e-words.jp/w/%E3%83%81%E3%83%A3%E3%83%AC%E3%83%B3%E3%82%B8-%E3%83%AC%E3%82%B9%E3%83%9D%E3%83%B3%E3%82%B9%E8%AA%8D%E8%A8%BC.html

### 14.8.7 ログインをユーザーに通知
クラックされた被害を最小限にする方法として、多くの企業で導入されている。
Geo-Locationを用いて、普段の位置情報と離れた場所からのアクセスの場合は再認証を行うケースも多い。
また"windows or macからログインされました"などユーザーエージェントからわかる情報を表示することもある。

## 14.9 脆弱性のコードのインジェクション
インジェクション: 注入
ライブラリに対して情報漏洩などを行うコードを追加されてしまうケースがある。
ライブラリやツールの脆弱性は、CVE, JVNなどでデータベース化されている。
npm、GitHubでも脆弱性検知機能が追加された。

## 14.10 ウェブアプリケーションのためのセキュリティガイドライン
IPA(情報処理推進機構)は日本語のガイドラインを後悔している。

## 14.11 webの広告とセキュリティ
テレビ広告ではみている人全てに同じ広告が出ていたが、webではユーザーの閲覧履歴から趣味嗜好を考慮し広告を出すことが可能になった。
ただユーザーの閲覧履歴を全て取得することはできないので、広告がユーザーにIDを割り振り、広告業者はトラッキングを行っているウェブサイト毎にユーザーが訪問したという情報を記録し、点をつなげてユーザーの閲覧履歴を復元するやり方がある。
計算方法は2種類ある。
- クッキーベースの計測ツールの場合はユーザーに対して固有のIDが当てられるため、クリックから3ヶ月以上のコンバージョンの成果まで取得できる。
- Finger Print方式では端末のブラウザバージョン情報やIPアドレス、地域情報、機種情報などを利用しユーザーをカテゴライズする。
ただ閲覧履歴は個人情報に当たるため、モバイルではAppleがユーザーが広告トラッキングを拒否できる設定が設けられていたり、ブラウザでも強化かされている。

### 14.11.1 サードパーティークッキー
クッキーを書き込みもとと違うサイトが読み取れるクッキーのこと。
複数の別サイトでのユーザーの閲覧履歴などを盗難された場合、より詳細なユーザー像を特定しやすくなる。

### 14.11.2  クッキー以外の代替手段
クッキーの場合は、セキュリティ強度によって無視したりリセットしたり、確認することが可能。
リセットしにくいクッキーもどき(通称ゾンビクッキー)を下記を用いて作成することが可能。
- HTML5の各種ストレージ(セッション、localstorage、グローバル)
- Etag
- ランダムに生成した画像
- その他、FlashやSilverlight、Javaアブレットなどの保存領域
Etagの場合は、絶対に変化しない画像ファイルなどのEtagにユーザーIDを入れてクライアントに送ることで実現する。
クライアントはページを表示するためのキャッシュの有効性を確認する。この時、サーバにEtag情報を送るため知らず知らずのうちにクッキーと同等のことが行われている。

### 14.11.3 Google Analytics
設置されたJavaScriptのコードを使用し、設置されたドメイン内でのユーザーの動きを正確に把握、分析できる。

### 14.11.4 ユーザーを特定せずに推定する (Finger Print)
Finger Print方式では端末のブラウザバージョン情報やIPアドレス、地域情報、機種情報などを利用しユーザーを推定する。
日本では大都市に人が集中している点と、iPhoneのシェアが高すぎるため、Finger Printではユーザのカテゴライズがうまく機能しない。
