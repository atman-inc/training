# Docker

学習者：m.sasaki

---

### コンテナとDocker
- コンテナとは
  - アプリケーションごとに**隔離された環境**を提供する仮想化の仕組み
- Dockerとは
  - 代表的なコンテナ実行ソフトウェア
  - コンテナランタイム、コンテナイメージの作成ツール、イメージを共有する仕組みも提供

- コンテナ利用のメリット
  - アプリケーションの動作環境を丸ごとパッケージング
  - 開発・テスト・本番でソフトウェアの実行環境のギャップを小さくすることができる
  - 軽量であるため扱いやすくリソースの利用効率も高い

<br>

- 別途購入した書籍でも学習を進めたい
  - 購入書籍「Docker&Kubernaetesのきほんのきほん」

---

### コンテナの仕組み
- VMとコンテナの違い
  - VM
    - イメージサイズが大きい
    - 起動が遅い
    - ホストと異なるOSの利用が可能
  - コンテナ
    - イメージサイズが比較的小さい
    - 起動が速い
    - ホストとカーネルを共有

<br>

- 用語
  - カーネル・・・OSの基本機能の役割を担うソフトウェア。動作中のプログラムの実行状態を管理したり、ハードウェア資源を管理してアプリケーションソフトがハードウェアの機能を利用する手段を提供したりする

<br>

- コンテナを実現するための技術要素
  - Linux namespace
    - プロセスに対してPID、ネットワーク、ユーザー、ホスト名等のリソースを分離することができる
  - cgroups
    - CPUやメモリ等のリソースを制限・隔離することができる
  - Linux capability
    - 特権ポートへのアクセスやiptablesの操作などの権限を制御する事ができる

---

#### 不明点の調査
- Linux namespace(名前空間)
  - プロセスをグループ化して、コンテナの隔離された空間を作り出す機能に重要な役割を果たす機能
  - 「名前空間」という独立した機能が1つ存在するわけではなく、独立したいリソースによっていくつかの機能がある
##### 名前空間の種類
| 名前空間の名前 | 隔離されるリソース | 実装されたカーネルバージョン |
| :----: | :----: | :----: |
| マウント名前空間 | マウントの集合、操作 | 2.4.19 |
| UTS名前空間 | ホスト名、ドメイン名 | 2.6.19 |
| PID名前空間 | プロセスID（PID） | 2.6.24 |
| IPC名前空間 | SysV IPCオブジェクト、<br>POSIXメッセージキュー | 2.6.19 |
| ユーザー名前空間 | UID、GID | 3.8 |
| ネットワーク名前空間 | ネットワークデバイス、<br>アドレス、<br>ポート、<br>ルーティングテーブル、<br>フィルタなど | 2.6.26 |

<br>

- cgroups
  - Control Group
  - プロセスをグループ化してそのグループ内に存在するプロセスに対して共通の管理を行うために使用する
    - 例
      - ホストOSが持つCPUやメモリ等のリソースに対してグループごとに制限をかけられる

<br>

- Linux capability
  - プロセスに特権を与えてしまうとプロセスに脆弱性があった場合に全ての特権を乗っ取られる危険性があった
  - それを解決する手段として提案された方法
  - 特権を細分化して「ケーパビリティ」と呼ばれる単位での取扱を可能にし、プロセスに必要最小限の「ケーパビリティ」を与えて必要な処理だけを行わせる

---

- MacやWindows上のDocker
  - 軽量なLinux VM上でDockerを動かしている
    - Docker Desktop for Mac / Windows
- 注意点
  - Mac版はホストとコンテナ間で共有するファイルのアクセスが遅い
  - コンテナ向けの実行ファイルはLinux用にビルドが必要

<br>

- Dockerの構成要素
  - Dockerfile
    - コンテナイメージの作成手順を記述したファイル

<br>

  - コンテナイメージ
    - コンテナ実行に必要なファイルなどをまとめたアーカイブファイル

<br>

  - コンテナ
    - 実際に実行されているコンテナ

<br>

  - Dockerコンテナランタイム
    - コンテナを実行するソフトウェア

<br>

  - コンテナレジストリ
    - コンテナイメージを共有するためのサービス（Docker Hub等）

<br>

- コンテナオーケストレーションツール
> 複数のコンテナを組み合わせたアプリケーションを実行したり管理するための仕組み
  - Docker-compose
    - シングルホスト上で複数のコンテナを組み合わせて実行するためのツール

<br>

  - Kubernetes
    - 複数のホスト上にコンテナを適切にスケジューリング
    - コンテナの自動復旧やアップグレード等様々な管理を行ってくれる

#### よく使うDockerコマンド
| コマンド | 動作 |
| :----: | :----: |
| run | コンテナの実行 |
| stop | コンテナの停止 |
| rm | コンテナの削除 |
| ps | コンテナの確認 |
| inspect | コンテナの詳細情報の取得 |
| exec | コンテナ上でコマンドの実行 |
| logs | コンテナのログを確認 |
| build | コンテナイメージのビルド |
| images | コンテナイメージの確認 |
| rmi | コンテナイメージの削除 |
| container prune | 停止コンテナの削除 |
| image prune | 未使用イメージの削除 |

---

### Dockerベストプラクティス：Dockerfile編

- Dockerfileの書き方
```yaml
FROM quay.io/cybozu/ubuntu:18.04 # ベースになるコンテナイメージの指定

# Docker build時に実行される処理
COPY ./myapp/work/myapp             # ホストからコンテナへのファイルコピー
WORKDIR /work/myapp                 # ワークディレクトリの指定
RUN make && make install            # 任意のコマンドの実行

# docker run時に実行されるコマンドや環境変数を指定
ENV PATH /usr/local/bin
CMD ["myapp", "--opt=hoge"]
```

#### Dockerfileのベストプラクティス
- 野良コンテナイメージは使用しない
  - 脆弱性や悪意のあるコードが含まれている可能性
  - Docker Official Imagesは比較的安全
  - Necoチーム提供のベースコンテナイメージ推奨
  - どれを使う場合も必ず調査をしっかりと行うこと

<br>

- コンテナイメージはできるだけ小さく
  - 大きなコンテナイメージ
    - ディスク容量を圧迫
    - ダウンロードに時間がかかる
  - コンテナイメージを小さくする方法
    - 小さなベースコンテナイメージを使用
    - レイヤーを意識する
      - RUNやCOPYを実行するたびにread-onlyなレイヤーが積み重なる
      - 上記からまとめてRUNを行う等の工夫をする
      - キャッシュを意識してレイヤーを分割
        - `docker build`の際は、変更の必要がないレイヤーはキャッシュが利用される
        - キャッシュを意識してレイヤーを分割すると`docker build`の時間短縮
        - ADDやCOPYコマンドでは、ファイルのチェックサムを利用して変更を検知している
    - multi-stage buildを使用
      - 1つのDockerfileを複数のステージに分けて記述できる
      - 利用例
        - ビルド用と実行用のステージを分離
        - ビルド用コンテナで実行ファイルをビルド
        - 実行ファイルを実行用コンテナにコピーしてイメージとして保存
      - ビルドに必要なツールや中間ファイルが実行用コンテナに含まれないため、イメージサイズを小さくできる

<br>

- コマンドを正しく使う
  - ADDとCOPY
    - ADDは予期せぬ動きをする場合がある
    - 通常はCOPYを使えば十分
  - ENTRYPOINTとCMD
    - コンテナ起動時に実行するコマンドが限定されている場合は「ENTRYPOINT」を使用
    - 色々なコマンドを実行して使うコンテナは「CMD」を使用

<br>

- タグを正しく使う
  - Dockerイメージのタグは容易に更新できてしまう
    - 同一のタグを使っているつもりが、異なるコンテナイメージ使っている場合があるので注意
    - タグ運用ルール例
      - レジストリに上げるイメージは**必ず固定タグを付ける**
      - 固定タグは変更しない
      - 利便性のためにブランチタグも利用可能
      - latestタグは利用しない

<br>

- Lintツールを使う
  - [hadolint](https://github.com/hadolint/hadolint)
    - Dockerfileの静的解析ツール

---

### Dockerベストプラクティス：アプリケーション編

#### コンテナアプリケーションのベストプラクティス
- コンテナはステートレスに
  - コンテナ内でアプリケーションを更新したり、ファイルを保存しない
    - 理由
      - コンテナが状態を保持すると、いつでもどこでも同じ構成であることが保証できなくなる
      - 状態を保持していなければ、コンテナをいつでも再起動したり更新できる
  - ステートレスにするには
    - コンテナイメージを更新するには、コンテナの中でコマンドを実行するのではなく、Dockerfileを変更する
    - データを永続化したい場合は、DockerやKubernetesの**Volume機能**を利用
    - `docker run`に`--read-only`オプションを指定

- 用語
  - Volume
    - Volumeはコンテナが利用するデータを永続化する為の仕組み
    - コンテナとライフサイクルが異なるため、コンテナを終了してもVolumeは消えない
    - 複数コンテナの間でVolumeを共有可能

<br>

- 1つのコンテナには1つの役割
  - コンテナは役割ごとに分割
    - 理由
      - コンテナイメージが再利用しやすくなる
      - スケールさせやすくなる
      - メンテナンスしやすくなる
  - docker-compose
    - 複数コンテナの起動を管理
    - 構成ファイルをdocker-compose.ymlに記述
    - 起動と停止
      - `docker-compose up # 起動`
      - `docker-compose down # 停止`

<br>

- 正しくログを出す
  - ファイルではなく、**標準出力** or **標準エラー出力**にログを出す
  - ログのローテーションや転送は、「Docker」や「Kubernetes」が用意しているログの仕組みに任せる

<br>

- シグナルを処理する
  - `docker stop`を実行するとコンテナに**SIGTERM**シグナルが飛んでくる
  - シグナルを受け取ったらアプリケーションを正しく終了させる
    - Graceful Shutdown機能として、ライブラリやWebサーバーが提供していることもある
    - Node.js等ではシグナルの扱いに注意

<br>

- ヘルスチェックの仕組みを用意する
  - コンテナが正しく動作しているか確認するための手段を用意
  - ヘルスチェック用のWeb APIを用意するのが一般的
  - 「Docker」の**HEALTHCHECK機能**や、「Kubernetes」の**livenessprobe機能**を利用して、コンテナの死活監視が可能
  - エラーが起きたら終了
    - アプリケーションが自力で解決できないエラーはプロセスを終了させる
      - 例
        - データベース接続エラー、設定ファイルの記述ミス等
    - エラーの検出・復旧やアラート通知は外部のシステムに任せる

<br>

- 柔軟なアプリケーション設定
  - アプリケーションの設定は外部から変更可能にする
    - 環境変数
    - コマンドラインオプション
    - 設定ファイル

<br>

- 不明点の調査
  - Linuxシグナル
    - プロセスとプロセスの間で通信を行う際に使用される**信号**
    - シグナルを受け取ったプロセスは「何かしらの動作」を行う

---

### コンテナアプリケーションを安全に動かす
- 最新のDockerを利用する
- ベースイメージを適切に更新
- docker.socketファイルの扱いに注意
- rootユーザーやprivileged権限で実行しない
- ホストへのアクセスは最小限に
- 秘密情報をコンテナイメージに含めない
- コンテナイメージの脆弱性のチェックを実施